"""
Author: Joon Sung Park (joonspk@stanford.edu)
Modifications by: Gemini

File: compress_sim_storage.py
Description: Compresses a simulation's output storage for replay demos
             by delta-compressing movement data and copying essential files.
"""
import shutil
import json
import argparse # Added
import os       # Added
import sys      # Added
# Assuming global_methods.py is in the same directory or accessible via Python path
# If global_methods is in backend_server, adjust import path if needed
# e.g., from backend_server.global_methods import ...
try:
    from global_methods import find_filenames, create_folder_if_not_there
except ImportError:
    # Try path relative to potential backend_server location if run from reverie
    sys.path.append(os.path.join(os.path.dirname(__file__), 'backend_server'))
    try:
        from global_methods import find_filenames, create_folder_if_not_there
    except ImportError:
        print("ERROR: Could not import global_methods. Ensure it's accessible.")
        sys.exit(1)


def compress(sim_code, fin_code):
    """
    Compresses simulation data from sim_code directory into fin_code directory.

    Args:
        sim_code (str): The name of the simulation run folder in storage/.
        fin_code (str): The name of the output folder in compressed_storage/.
    """
    # --- Construct paths relative to the script's directory ---
    script_dir = os.path.dirname(os.path.abspath(__file__)) # Get script's absolute directory

    # --- CORRECTED PATH LOGIC ---
    # If script is in GA/reverie/, go up one level ('..') to get to GA/
    base_dir = os.path.abspath(os.path.join(script_dir, '..'))
    # --- END CORRECTION ---

    # Construct full paths relative to the GA/ directory
    storage_dir = os.path.join(base_dir, "environment/frontend_server/storage")
    compressed_dir = os.path.join(base_dir, "environment/frontend_server/compressed_storage")

    sim_storage = os.path.join(storage_dir, sim_code)
    # Use fin_code for the output directory name
    compressed_storage = os.path.join(compressed_dir, fin_code)

    persona_folder = os.path.join(sim_storage, "personas")
    move_folder = os.path.join(sim_storage, "movement")
    # Adjust meta file path assumption if needed - check both possibilities
    # Assuming meta file is generated by reverie_offline.py inside the sim_code folder
    meta_file_reverie = os.path.join(sim_storage, "reverie/meta.json") # Original path check
    meta_file_root = os.path.join(sim_storage, "meta.json") # Check root of sim_code folder too

    print(f"Source storage: {sim_storage}")
    print(f"Target compressed storage: {compressed_storage}")

    # --- Basic Error Handling: Check if source exists ---
    if not os.path.isdir(sim_storage):
        print(f"ERROR: Source simulation directory not found: {sim_storage}")
        sys.exit(1)
    if not os.path.isdir(persona_folder):
        print(f"ERROR: Source personas directory not found: {persona_folder}")
        # Allow continuing without personas? Maybe just movement/meta needed?
        # For now, let's make it non-critical, but log warning.
        print(f"WARN: Source personas directory not found: {persona_folder}. Personas will not be copied.")
        persona_folder = None # Flag that personas are missing
        # sys.exit(1) # Original stricter exit
    if not os.path.isdir(move_folder):
        print(f"ERROR: Source movement directory not found: {move_folder}")
        sys.exit(1) # Movement data is essential

    # Determine meta file path
    meta_file = None
    if os.path.isfile(meta_file_reverie):
         meta_file = meta_file_reverie
    elif os.path.isfile(meta_file_root):
         meta_file = meta_file_root

    if meta_file is None:
         print(f"ERROR: Meta file not found at expected locations:")
         print(f"  - {meta_file_reverie}")
         print(f"  - {meta_file_root}")
         sys.exit(1) # Meta file is likely essential
    # --- End Error Handling ---

    try:
        # --- Get Persona Names (Only if folder exists) ---
        persona_names = []
        if persona_folder: # Check if persona_folder was found
            try:
                 for item in os.listdir(persona_folder):
                     item_path = os.path.join(persona_folder, item)
                     if os.path.isdir(item_path) and not item.startswith('.'):
                         persona_names.append(item)
            except FileNotFoundError:
                 # This shouldn't happen due to earlier check, but for safety
                 print(f"ERROR: Cannot list personas, directory disappeared: {persona_folder}")
                 persona_folder = None # Treat as missing

            if not persona_names:
                 print(f"WARN: No persona folders found in {persona_folder}. Proceeding without persona-specific data in movement.")
                 # Allow continuing, but movement delta logic might be less effective
            else:
                 print(f"Found personas: {persona_names}")
        else:
             print("Proceeding without persona data (folder was missing).")


        # --- Find Movement Files ---
        try:
             movement_files = [f for f in os.listdir(move_folder)
                               if f.endswith('.json') and f[:-5].isdigit()]
        except FileNotFoundError:
             print(f"ERROR: Cannot list movement files, directory not found: {move_folder}")
             sys.exit(1)

        if not movement_files:
             print(f"ERROR: No valid movement json files found in {move_folder}")
             sys.exit(1)
        max_move_count = max([int(f.split(".")[0]) for f in movement_files])
        print(f"Found movement steps up to: {max_move_count}")

        # --- Process Movement Data (Delta Compression) ---
        persona_last_move = dict() # Stores the last recorded state for each persona
        master_move = dict()       # Stores the delta-compressed states
        print("Processing movement data...")
        for i in range(max_move_count + 1):
            master_move[i] = dict() # Initialize step entry
            move_file_path = os.path.join(move_folder, f"{str(i)}.json")
            try:
                with open(move_file_path) as json_file:
                    try:
                        i_move_dict_full = json.load(json_file)
                        i_move_dict = i_move_dict_full.get("persona")
                        if i_move_dict is None:
                             print(f"WARN: 'persona' key not found in {move_file_path}. Skipping step {i}.")
                             continue
                    except json.JSONDecodeError:
                        print(f"WARN: Could not decode JSON from {move_file_path}. Skipping step {i}.")
                        continue

                    # Iterate through personas found in *this step's* file
                    for p in i_move_dict.keys():
                        # If we are tracking specific personas, ensure this one is tracked
                        if persona_names and p not in persona_names:
                             continue # Skip if persona not in the list from persona_folder

                        current_state = i_move_dict[p]
                        last_state = persona_last_move.get(p)

                        store_state = False
                        if i == 0 or last_state is None:
                            store_state = True
                        elif (current_state.get("movement") != last_state.get("movement")
                              or current_state.get("pronunciatio") != last_state.get("pronunciatio")
                              or current_state.get("description") != last_state.get("description")
                              or current_state.get("chat") != last_state.get("chat")):
                            store_state = True

                        if store_state:
                            state_to_store = {
                                "movement": current_state.get("movement"),
                                "pronunciatio": current_state.get("pronunciatio"),
                                "description": current_state.get("description"),
                                "chat": current_state.get("chat")
                            }
                            persona_last_move[p] = state_to_store
                            master_move[i][p] = state_to_store

            except FileNotFoundError:
                print(f"WARN: Movement file not found for step {i}: {move_file_path}. Skipping.")
                if i in master_move: master_move.pop(i) # Remove empty step entry
                continue
            except KeyError as e:
                 print(f"WARN: Missing expected key '{e}' in step {i} for persona '{p}' in {move_file_path}. Skipping persona for this step.")
                 continue
            except Exception as e:
                 print(f"ERROR processing step {i} for file {move_file_path}: {type(e).__name__} {e}")
                 continue

        # --- Save Compressed Data ---
        print("Saving compressed data...")
        create_folder_if_not_there(compressed_storage) # Uses global_methods

        master_movement_path = os.path.join(compressed_storage, "master_movement.json")
        try:
            with open(master_movement_path, "w") as outfile:
                json.dump(master_move, outfile, indent=2)
            print(f"Saved compressed movement data to: {master_movement_path}")
        except TypeError as e:
             print(f"ERROR: Data in master_move not JSON serializable: {e}")
             # sys.exit(1) # Maybe allow continuing without movement?
        except IOError as e:
             print(f"ERROR: Could not write master movement file: {e}")
             # sys.exit(1)

        # Copy meta file
        compressed_meta_path = os.path.join(compressed_storage, "meta.json")
        try:
            shutil.copyfile(meta_file, compressed_meta_path)
            print(f"Copied meta file to: {compressed_meta_path}")
        except FileNotFoundError:
             print(f"ERROR: Meta file source not found: {meta_file}")
             # Decide if this is critical
        except Exception as e:
            print(f"ERROR: Could not copy meta file '{meta_file}' to '{compressed_meta_path}': {e}")

        # Copy personas folder (only if it was found)
        if persona_folder:
            compressed_personas_path = os.path.join(compressed_storage, "personas")
            try:
                if os.path.exists(compressed_personas_path):
                     shutil.rmtree(compressed_personas_path)
                shutil.copytree(persona_folder, compressed_personas_path)
                print(f"Copied personas folder to: {compressed_personas_path}")
            except FileNotFoundError:
                 print(f"ERROR: Personas source folder not found during copy: {persona_folder}")
                 # sys.exit(1) # Decide if critical
            except Exception as e:
                print(f"ERROR: Could not copy personas folder '{persona_folder}' to '{compressed_personas_path}': {e}")
                # sys.exit(1) # Decide if critical

        print("Compression complete.")

    except Exception as e:
        print(f"An unexpected error occurred during compression setup or execution: {type(e).__name__} - {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    # --- Argument Parsing --- Added ---
    parser = argparse.ArgumentParser(
        description="Compresses simulation storage from <sim_code> folder into <fin_code> folder for replay.",
        usage='%(prog)s sim_code fin_code' # Custom usage message
        )
    parser.add_argument("sim_code", type=str,
                        help="The simulation code (folder name in storage/) to compress.")
    parser.add_argument("fin_code", type=str,
                        help="The desired output folder name that will appear in compressed_storage/")

    # Check if enough arguments were provided before parsing
    if len(sys.argv) < 3:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    # --- End Argument Parsing ---

    # --- Call compress function with parsed arguments --- Changed ---
    compress(args.sim_code, args.fin_code)
    # --- End Call ---
